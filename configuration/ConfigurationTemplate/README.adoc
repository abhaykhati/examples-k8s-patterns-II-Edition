== Configuration Template

This example demonstrates the usage of the **Configuration Template** pattern. As described in detail in our book this pattern is useful for dynamically creating configuration during application startup by processing templates on the fly. Please check out the pros and cons of this approach from the book.

=== Wildfly configured with templates and configmaps

In this example we will configure a Wildfly application server. As you probably know, Wildlfy uses an XML syntax for its configuration which can be quite lengthy. We will use a configuration template where we want to configure only a small part differently for different environments. In our example we use a `standalone.xml` template which is filled with values from a `ConfigMap` before the server starts.

The only datum we are want to adapt in this simple example is the log format. The format is adapted so that each log line is prefixed with the environment it is running (`prod` or `dev`). We parameterise `standalone.xml` for this with the link:init-container/in/standalone.xml#L122[single line]:

[source, xml]
----
<formatter name="COLOR-PATTERN">
   <pattern-formatter pattern="{{ (datasource "config").logFormat }}"/>
</formatter>
----

As a template processor https://github.com/hairyhenderson/gomplate[gomplate] is used which has the notion of "datasources". The template syntax please refer to https://gohugo.io/templates/go-templates/[Go Templates].
Actually its an slightly adapted gomplate so that it fits our use case better. You found the changed version in the https://github.com/rhuss/gomplate[rhuss/gomplate] repo.

As described in the pattern's description an Kubernetes init container that contains the templates is also used for processing the templates. The docker build files for this container are in link:init-container[init-container].

Please check its link:init-container/README.md[README] how to re-create the image, but we already pushed it to Docker hub for your convenience.

=== Running the example

The value to fill into the template come from config map which needs to be created first.

We create two configmaps with name `dev-params` and `prod-params` from the directories link:dev[dev] and link:prod[prod]. Both contain sample configurations in a file "config.yml" that can be used in the link:init-container/in/standalone.xml#L122[standalone.xml] template.

To create the config maps that we use (assuming the current working directory is the directory of this README), for both, a development and a production environment:

[source, bash]
----
kubectl create configmap dev-params --from-file=dev
----

[source, bash]
----
kubectl create configmap prod-params --from-file=prod
----


Then start the service and deployment as specified in link:wildfly.yml[wildfly.yml]:

[source, bash]
----
kubectl apply -f https://k8spatterns.io/ConfigurationTemplate/wildfly.yml
----

In order to check that the configuration was processed properly check now the logs:

[source, bash]
----
kubectl logs -f $(kubectl get pod -l app=wildfly -o name) server
----

----
....
DEVELOPMENT: 14:52:14,049 INFO  [org.jboss.ws.common.management] (MSC service thread 1-4) JBWS022052: Starting JBossWS 6.1.0.Final (Apache CXF 3.5.2.jbossorg-3)
DEVELOPMENT: 14:52:14,094 INFO  [org.jboss.as.server] (Controller Boot Thread) WFLYSRV0212: Resuming server
DEVELOPMENT: 14:52:14,096 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly Full 27.0.0.Final (WildFly Core 19.0.0.Final) started in 2135ms - Started 290 of 563 services (357 services are lazy, passive or on-demand) - Server configuration file in use: standalone.xml
DEVELOPMENT: 14:52:14,097 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0060: Http management interface listening on http://127.0.0.1:9990/management
DEVELOPMENT: 14:52:14,098 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0051: Admin console listening on http://127.0.0.1:9990
.... 
----

Note the added prefix `DEVELOPMENT` which comes from the config map.

Now let's switch over to the `prod-params` by patching the deployment:

[source, bash]
----
kubectl patch deployment wildfly \
  -p '{"spec": {"template": {"spec": {"volumes": [{"name": "wildfly-params", "configMap": {"name": "prod-params"}}]}}}}'
----

and then check the log again with

[source, bash]
----
kubectl logs -f $(kubectl get pod -l app=wildfly -o name) server
----

----
....
PRODUCTION: 14:49:04,729 INFO  [org.jboss.as.server.deployment.scanner] (MSC service thread 1-1) WFLYDS0013: Started FileSystemDeploymentService for directory /opt/jboss/wildfly/standalone/deployments
PRODUCTION: 14:49:04,745 INFO  [org.jboss.ws.common.management] (MSC service thread 1-3) JBWS022052: Starting JBossWS 6.1.0.Final (Apache CXF 3.5.2.jbossorg-3)
PRODUCTION: 14:49:04,785 INFO  [org.jboss.as.server] (Controller Boot Thread) WFLYSRV0212: Resuming server
PRODUCTION: 14:49:04,786 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly Full 27.0.0.Final (WildFly Core 19.0.0.Final) started in 2068ms - Started 290 of 563 services (357 services are lazy, passive or on-demand) - Server configuration file in use: standalone.xml
PRODUCTION: 14:49:04,787 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0060: Http management interface listening on http://127.0.0.1:9990/management
PRODUCTION: 14:49:04,788 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0051: Admin console listening on http://127.0.0.1:9990
....
----

That concludes our demo and how you can easily parameterise big configuration files with values that you store in a configmap.

Please also have a look to the comments within link:wildfly.yml[wildfly.yml] which explain this examples in even more details.


=== More Information

* https://oreil.ly/gzSdc[Configuration Template Example]
* https://oreil.ly/0gPNC[Tiller Template Engine]
* https://oreil.ly/e-5mR[Gomplate]
* https://oreil.ly/fHi0o[Go Template Syntax]
