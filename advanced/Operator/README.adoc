== Operator

This advanced example introduces a simple *Operator* which is based on the config watcher link:../Controller/README.adoc[Controller], so we recommend to try controller demo first.

Here we add a dedicated _Custom Resource Definition_ (CRD) `ConfigWatcher` which turns our controller into an Operator.

For a detailed explanation of how this demo works, please refer to the _Operator_ pattern in out book, this document gives you a brief walk-through the example code.

NOTE: Before we start, please ensure that you have stopped the link:../Controller/config-watcher-controller.yml[controller deployment] from the Controller demo. You can easily remove it also by a `kubectl delete -f config-watcher-controller.yml`. Actually, the ideal would be to setup this operator demo in a fresh namespace.

WARNING: Again the warning, that this is example is meant for educational purposes only and is not suitable for general purpose usage.


The following steps assume you are using `minikube`. More options for running the example are described in the link:../../INSTALL.adoc#minikube[installation instructions].

As a first step, we have to install the CRD along with a role to allow to modify custom resource created for this CRD:

[source, bash]
----
kubectl apply -f https://k8spatterns.io/Operator/config-watcher-crd.yml
----

Verify that the CRD is registered:

[source, bash]
----
kubectl get crd
----

The operator script itself is stored in a `ConfigMap`:

[source, bash]
----
kubectl create configmap config-watcher-operator --from-file=./config-watcher-operator.sh
----

In order to deploy the operator a `Deployment` creates a pod with two containers:

* One Kubernetes API proxy which exposes the Kubernetes API on localhost with port 8001. The image for `k8spatterns/kubeapi-proxy` is defined in this link:../images/kubeapi-proxy.dockerfile[Dockerfile].
* The main container which executes the script from the `ConfigMap`. It is based on a single Alpine base image with https://curl.haxx.se/[curl] and https://stedolan.github.io/jq/[jq] included. The Dockerfile for this image `k8spattern/curl-jq` can be found link:../images/curl-jq.dockerfile[here].

Both images, https://cloud.docker.com/u/k8spatterns/repository/docker/k8spatterns/kubeapi-proxy[k8spatterns/kubeapi-proxy] and https://cloud.docker.com/u/k8spatterns/repository/docker/k8spatterns/curl-jq[k8spatterns/curl-jq] are available from Docker Hub.

To create this deployment in the current namespace, call:

[source, bash]
----
kubectl apply -f https://k8spatterns.io/Operator/config-watcher-operator.yml
----

To see our operator in action, we are reusing the same super simple web application as for the `Controller` example.
This image just exposes an environment variable as HTTP content on any request.
This link:../images/mini-http-server.dockerfile[image] uses `nc` to deliver the content and can be found on Docker Hub as https://cloud.docker.com/u/k8spatterns/repository/docker/k8spatterns/mini-http-server[k8spatterns/mini-http-server].

Before we deploy this app, we should tail on the log of our operator in another terminal to see the events received by the operator as they come in:

[source,bash]
----
kubectl logs -f $(kubectl get pods -l role=operator -o name) config-watcher
----


Then create the web application itself:

[source, bash]
----
kubectl apply -f https://k8spatterns.io/Operator/web-app.yml
----

If you look into this descriptor file, you will find the same `Deployment` using our dumb HTTP server which references the content environment variable via a `ConfigMap`.
In contrast to the other controller example the `ConfigMap` does *not* contain a reference to the pods to restart.

With minikube, access the application in your browser:

[source, bash]
----
minikube service webapp
----

(use option `-n namespace` if you have deployed this example in a different namespace than `default).

Stop the tunnel created by `minikube service` (with `CTRL-C`), update the content of `ConfigMap`, and watch the controller's log:

If you change the config map now, it doesn't change anything.
We have to first install a concreate custom resource of kind `ConfigWatcher` to trigger the operator on a config change:

[source,bash]
----
kubectl apply -f https://k8spatterns.io/Operator/config-watcher-sample.yml
----

Check that the resource has been created

[source, bash]
----
kubectl get configwatchers
----

After this connection between `ConfigMap` and `Pods` has been configured, change the content of `ConfigMap` and watch the operator log:

[source, bash]
----
kubectl patch configmap webapp-config \
   -p '{"data":{"message":"Greets from your smooth operator!"}}'
----

and then finally call the URL again to check that the content has been updated

[source,bash]
----
minikube service webapp
----

=== More Information

* https://oreil.ly/iN2B4[Operator Example]
* https://oreil.ly/aIGNA[OpenAPI V3]
* https://oreil.ly/GeHKy[Kubebuilder]
* https://oreil.ly/5JWcN[Operator Framework]
* https://oreil.ly/etanj[Metacontroller]
* https://oreil.ly/1iiab[Client Libraries]
* https://oreil.ly/8ungP[Extend the Kubernetes API with CustomResourceDefinitions]
* https://oreil.ly/0xhlw[Custom Resources]
* https://oreil.ly/kyIsL[Sample-Controller]
* https://oreil.ly/voY92[What Are Red Hat OpenShift Operators?]
