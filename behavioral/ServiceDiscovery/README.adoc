== Service Discovery

IMPORTANT: The instructions have not been written/finished, but the resource file has been verified. Instructions will be added soon.

In these examples we learn various ways how to discover and access services with _Service Discovery_.

ifndef::skipInstall[]
We are using a Minikube installation to run the examples. Please refer to the link:../../INSTALL.adoc#minikube[installation instructions] for details.

The examples here expect that you have an Ingress controller and a load balancer enabled. For Minikube, you can enable both with

[source, bash]
----
minikube addons enable ingress
----

and in a separate terminal start a https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access[minikube tunnel]. The following call will start the tunnel in the foreground. You can stop it with `CTRL-C`.

[source, bash]
----
minikube tunnel
----
endif::skipInstall[]

We are using our `random-generator` application as the deployment which we want to expose.

So, first we are exposing this service with 4 replicase with:

[source, bash]
----
kubectl apply -f https://k8spatterns.io/ServiceDiscovery/deployment.yml
----

Now lets just create a simple service which dispatches to these four pods dynamically:

==== Cluster-internal Service

[source, bash]
----
kubectl apply -f https://k8spatterns.io/ServiceDiscovery/service.yml
----

This service is of type `ClusterIP` so only reachable from within the cluster.
You can verify this by calling `kubectl get svc`.

Let's verify that this service can reached from within the cluster:

[source, bash]
----
# Create a debug sattelite Pod that we jump into later
kubectl run dbg --image=k8spatterns/curl-jq --command -- sleep infinity
# Jump into the debug pod
kubectl exec -it dbg -- ash
----

Now do some checks:

[source, bash]
----
# Check DNS entry
dig random-generator.default.svc.cluster.local
----

[source, bash]
----
# Curl to service `random-generator`
curl -s http://random-generator:8080 | jq .
----

You can also check whether, the service coordinates are exposed via environment variables within the pods:

[source, bash]
----
# Check for exposed service variables in our test Pod
env | grep RANDOM
----

=== Service with type NodePort

After you left the Pod, lets switch to `NodePort` as service type

[source, bash]
----
# Update service to type NodePort
kubectl apply -f https://k8spatterns.io/ServiceDiscovery/service-with-nodeport.yml
----

Now we can access our service from the _outside_ the cluster, namely from your desktop's shell:

[source, bash]
----
# Pick port from the service definition and curl
port=$(kubectl get svc random-generator -o jsonpath={.spec.ports[0].nodePort})
curl -s http://$(minikube ip):$port | jq .
----

=== Service with type LoadBalancer

NOTE: If you are not using Minikube, use the hostname/IP address of one of your cluster's node)

[source, bash]
----
# Update service to type LoadBalancer
kubectl apply -f https://k8spatterns.io/ServiceDiscovery/service-with-loadbalancer.yml
----

If your cluster provides a loadbalancer you will get the loadbalancers IP when looking at it with `kubectl get service`. Otherwise the field `EXTERNAL IP` will stay in status _<pending>_.

NOTE: As mentioned previously, for Minikube, start `minikube tunnel` to add some routing from your localhost to the Minikube IP.

When Kubernetes has assigned an external IP address to your service (check with `kubectl get service`), you can query it via this IP address and the Service's port:

[source, bash]
----
# Pick port from the service definition and curl
ip=$(kubectl get svc random-generator -o jsonpath={.status.loadBalancer.ingress[0].ip})
curl -s http://$ip:8080 | jq .
----

==== Ingress

Finally, let's have a look to an Ingress exposed Service.

First, we reset our Service back to type `ClusterIP`:

[source, bash]
----
kubectl delete service random-generator
kubectl apply -f https://k8spatterns.io/ServiceDiscovery/service.yml
----

Next, let's create the `Ingress` object with

[source, bash]
----
kubectl apply -f https://k8spatterns.io/ServiceDiscovery/ingress.yml
----

You can check the create Ingress object as usual with `kubectl get ingress`. Note, that you should now have an `ADDRESS` assigned if your cluster has an ingress controller running.

On Minikube this can be done via `minikube addons enable ingress`.

You can query now our internal Service over this Ingress with

[source, bash]
----
curl -s http://$(minikube ip)/
----

=== More Information

* https://github.com/k8spatterns/examples/tree/master/behavorial/ServiceDiscovery[Service Discovery example]
* https://kubernetes.io/docs/concepts/services-networking/service/[Kubernetes Services]
* https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/[DNS for Services and Pods]
* https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/[Debug Services]
* https://kubernetes.io/docs/tutorials/services/[Using Source IP]
* https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip[Create an External Load Balancer]
* https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0[Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what?]
* https://kubernetes.io/docs/concepts/services-networking/ingress/[Ingress]
